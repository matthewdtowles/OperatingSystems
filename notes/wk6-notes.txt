10. Memory Management

10.1 Introduction
- memory manager allocates and deallocates main memory
- main memory is one of the most important resources in a computer system
- # of partitions in memory = max # of processes that can reside in memory
- fragmentation = existence of allocated memory not used by process
    - or small memory blocks that cannot be allocated to a process
    - reduces memory utilization
- noncontiguous memory helps reduce fragmentation with smaller blocks 
    - uses segmentations, virtual memory
    
    
10.2 Process Address Space
- logical address = reference to location of a process.
- process address space = set of logical addresses that a process references
- 3 types of addresses are used in a program:
    1. Symbolic addresses:
        - variable names
        - symbolic constants
        - instruction labels
    2. Relative addresses: 
        - compiler converts symbolic into relative
    3. Physical addresses: 
        - final address generated when program loaded and ready to execute

10.2.1 Binding
- compiler translates symbolic addresses into relative or relocatable addresses.
    - result is an object program in machine language
- object program and other object modules combined into an absolute program
    - has logical addresses
    - defines the complete set of logical addresses the program can reference
        - aka: the process address space.
- memory manager allocates a block of memory locations to the absolute program
    - loader moves the program into the allocated memory block
- At load time:
    - absolute program loaded
    - relocatable addresses mapped to physical addresses
    - each logical address is bound to a physical address in memory
- Absolute program becomes an executable after logical addresses are mapped to physical addresses
- EDITOR (symbolic addresses) --> 
    COMPILER/ASSEMBLER (relative addresses) -->
        LINKER/OTHER COMPILED MODULES (relative addresses) -->
            LOADER (physical addresses) -->
- early/static binding = mapping carried out before execution time
- late/dynamic binding = delays mapping until process starts to execute

10.2.2 Static and Dynamic Loading
- static loading:
    - absolute program loaded into memory for execution to start
- dynamic loading:
    - external library are not loaded with program
        - routines library are stored on disk and loaded into memory when needed
    - improves memory utilization

10.2.3 Static and Dynamic Linking
- static linking:
    - linker combines all modules needed single absolute load module before execution
- dynamic linking:
    - building absolute form of program delayed until execution 
    - for every call to a routine of a library, a stub is executed to find the appropriate library in memory
    - only a single copy of a shared library is needed in memory


10.3 Contiguous Memory Allocation
- memory manager provides 3 basic functions:
    1. partitioning 
    2. protection of partition allocated to process from the memory references generated by a process in a different partition. 
    3. management of shared memory in a partition by 2+ processes

10.3.1 Fixed Partitions
- fixed-sized partitions not normally same size
- one partition allocated per active process
- fragmentation = the portion of memory allocated but not used
- internal fragmentation = unused portion of memory inside a partition

10.3.2 Dynamic Partitions
- system allocates a block of memory sufficiently large 
- partition is created dynamically, when there is sufficient memory available 
- number of partitions is also variable.
- memory manager allocates until:
    - there is no more memory available or 
    - until there are no more processes waiting 
- contiguous blocks of unallocated memory are called holes
- dynamics partition techniques (3): 
    1. best-fit: selects the hole closest in size to process
    2. first-fit: selects first available hole large enough for process
    3. next-fit: selects next hole large enough for process
        - starting at the location of last allocation.
- compaction reduces external fragmentation
    - moves processes to different locations in memory to merge small holes

10.3.3 Swapping
- when a process is blocked system can swap out the blocked process to disk to make that memory available
    - then system swaps back the process from disk 
- for swapping to be effective:
    - time to move to disk and copy back to main mem must be < time process will spend blocked


10.4 Noncontiguous Memory Allocation
- two common techniques for noncontiguous memory allocation: paging and segmentation.

10.4.1 Paging
- pages = small fixed-sized blocks of logical memory
- process address space is divided into pages
- size of process = # of pages
- frames = small fixed-sized blocks of physical memory
- physical memory is divided into frames
- size of page = 2^n = size of frame
- no external fragmentation
    - potential for a small amount of internal fragmentation on last page of a process 

10.4.1.1 Logical Addresses
- have a page number & an offset
- most significant bits = page number 
- least significant bits = offset 
- when system allocates a frame to this page:
    - it translates this logical address into a physical address
        - consists of a frame number & the offset
- page table shows page to frame corresondence
    - array or linked list

10.4.1.2 Address Translation
- os maintains a table of empty frames
- os maintains a table with frame allocation to each page of the process
- logical.pageNumber is index into page table
- page table entry is in physical memory as a frame 
- logical.pageOffset in physical memory- page table includes a bit that indicates if the page is currently stored in physical memory
- another bit indicates if the page has been modified
    - if not modified:  no need to swap the page back to virtual memory
- managing page tables affects performance
    - solution: store it in virtual memory and only load the part of the table with the entry of the page currently being referenced
    - another solution: a page directory is always kept in memory
        - every entry in this page directory points to a page table

10.5.7 Page Size Considerations
- small page size => small amt of internal fragmentation
    - => large amt of pages => large page table => larger amt of disk accesses
- translation done by appending frame number to offset

10.4.2 Segmentation
- segment = variable length module of program
    - correspond to logical unites of program 
    - example: a function in a program 
- each segment must be in contiguous block 
- all segments for a program may be non-contiguous
- differences between segmentation and paging:
    1. segments of a process are NOT same size 
    2. segments are large compared to pages 
    3. number of segments of a process is small
- os maintains a segment table just like a paging table


10.5 Virtual Memory

10.5.1 Basic Concepts
- after linkage, absolute version of program is stored on disk
- disk area that stores all the processes in absolute form is called the virtual memory
- only a portion of the process will ever be loaded into main memory
- page reference = page that has address being referenced
- virtual memory manager swaps in a page of an executing process whenever the execution of a process references a page that is not in physical memory
    - an unused page will normally be swapped out to a disk

10.5.2 Process Locality
- reference locality = behavior which exec'ing process references a subset of its addresses in a given time interval
- process locality = subset of pages referenced during one of a processes many phases of executing
- locality = a subset of pages for a process

10.5.3 Using Segments
- program executes with only a few segments loaded into memory
- user/programmer has some control over segment size 
- otherwise, much the same as paging in virtual memory 

10.5.4 Memory Protection
- two goals:
    1. Processes will not adversely affect other processes.
        - done by ensuring a process can only access memory in its own address space
    2. Programming errors will be caught before large amounts of damage can be done.
        - done by portions of the process's memory being marked as follows:
            - Read enabled: The memory can be read as data.
            - Write enabled: Variables in this area can be changed.
            - Execute enabled: The area contains instructions.

10.5.6 Address Translation
- corresponding page is looked up in the page table of the process
    1. system needs to check if the referenced page corresponds to a valid reference. 
    2. it needs to find out whether the page is stored in physical memory
        2.a. if so: 
        3. system finds frame that has been allocated to the page
        4. physical address is constructed using the frame address and the page offset. 
        5. with this physical address - the main memory is accessed


10.6 Paging with Virtual Memory
- os needs hardware support for translation from virtual to physical address
- page fault = process references page not in memory 
    - os must interrupt and fetch page from disk 

10.6.1 Paging Policies
- issues to be resolved to implement virtual memory:
    - fetch policy = when to swap in a page
    - replacement policy = the selection of the page in memory to replace when there are no empty frames
    - placement policy = selection of the frame in which to place the page that was fetched
    - number of frames to allocate to a process

10.6.1.1 Fetch Policy
- 2 approaches to consider:
    1. Demand paging = page not loaded until referenced by a process
    2. Prepaging = page loaded before referenced by a process.

10.6.1.2 Replacement Policy
- what os does when a page fault occurs:
    1. The process that generated the page fault is suspended
    2. OS locates the referenced page in the secondary storage device, using the page tables
    3. If no frames are free -> a page is selected to be replaced
        - this page is transferred back to the secondary storage device if modified
    4. The referenced page is loaded into the selected frame, and the page and frame tables are updated.
    5. The interrupted program is scheduled to resume execution.

10.6.2 Frame Allocation
- 2 groups of paging algorithms:  static vs dynamic allocation
- static allocation: system allocates fixed # of frames to a process
- dynamic allocation: system dynamically changes # of frames it allocates to a process during its execution.
- more frames = better performance (for that process)
- too many frames to a process reduces degree of multiprogramming
    - which reduces overall performance 
- too few frames = too many page faults 
    - can lead to thrashing 
    - thrashing = processes make no progress due to high # of page faults 
- equal allocation: divides available frames equally among the active processes
- proportional allocation: # of frames proportional to its size (in pages) and also depends on the priority of the process

10.6.3 Page Faults and Performance Issues
- factors that hit performance on page faults:
    - service the page fault interrupt
    - store back (swap out) the replaced page to disk
    - load (swap in) the referenced page from disk
        * swap out/in together is most significant factor *
    - delay in queuing for the disk
    - delay in scheduling the process with the referenced page


10.7 Paging Algorithms

10.7.1 Static Paging Algorithms

10.7.1.1 FIFO Algorithm
- page selected to be replaced is the one that has been in memory the longest
- worst performance 

10.7.1.2 Optimal Algorithm
- requires knowledge of entire page reference stream in advance 
- looks at future references to page in physical memory before replacing 
- replaces the page in memory that will NOT be used for the longest period 
- not usually possible in practice 
    - useful as a reference for comparison

10.7.1.3 Least Recently Used
- replaces page that has not been used for the longest period


10.8 Thrashing
- A condition or state in the system in which all the time a process spends is dedicated for swapping pages 
    - No computation is carried out by the process 
- can cause other processes to begin thrashing as OS attempts to increase multiprogramming as a response
